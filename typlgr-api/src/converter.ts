/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* function calcScore(text: string): number {
*     return addScoreDialesis(text,
*             addScoreBreath(text,
*             addScoreAccent(text,
*             addScoreIotaSubscriptum(text))));
* }
* function addScoreDialesis(text: string, score=0): number {
*     if (text.includes('"')) {
*         return 4 ** 3 + score;
*     } else {
*         return score;
*     }
* }
* function addScoreBreath(text: string, score=0): number {
*     if (text.includes('<')) {
*         return 4 ** 2 * 1 + score;
*     } else if (text.includes('>')) {
*         return 4 ** 2 * 2 + score;
*     } else {
*         return score;
*     }
* }
* function addScoreAccent(text: string, score=0): number {
*     if (text.includes("'")) {
*         return 4 ** 1 * 1 + score;
*     } else if (text.includes('\`')) {
*         return 4 ** 1 * 2 + score;
*     } else if (text.includes('~')) {
*         return 4 ** 1 * 3 + score;
*     } else {
*         return score;
*     }
* }
* function addScoreIotaSubscriptum(text: string, score=0): number {
*     if (text.includes('|')) {
*         return 1 + score;
*     } else {
*         return score;
*     }
* }
* ---
* letters := children=letter*
*     .value = string { return this.children.map(l => l.value).join(''); } 
* letter :=
*       alphabet
*     | punctuation
*     | anyChar
* alphabet :=
*       largeAlpha
*     | largeEpsilon
*     | largeEta
*     | largeIota
*     | largeOmicron
*     | largeUpsilon
*     | largeOmega
*     | largeBeta
*     | largeGamma
*     | largeDelta
*     | largeZeta
*     | largeKappa
*     | largeLambda
*     | largeMu
*     | largeNu
*     | largeXi
*     | largePi
*     | largeRho
*     | largeSigma
*     | largeTau
*     | smallAlpha
*     | smallEpsilon
*     | smallEta
*     | smallIota
*     | smallOmicron
*     | smallUpsilon
*     | smallOmega
*     | smallBeta
*     | smallGamma
*     | smallDelta
*     | smallZeta
*     | smallKappa
*     | smallLambda
*     | smallMu
*     | smallNu
*     | smallXi
*     | smallPi
*     | smallRho
*     | smallSigma
*     | smallTau
* largeAlpha := text='[<>]?[\'`~]?A\|?'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FBC';
*             case  4: return '\u1FBB';
*             // case  5: return '\uxxxx';
*             case  8: return '\u1FBA';
*             // case  9: return '\uxxxx';
*             // case 12: return '\uxxxx';
*             // case 13: return '\uxxxx';
*             case 16: return '\u1F09';
*             case 17: return '\u1F89';
*             case 20: return '\u1F0D';
*             case 21: return '\u1F8D';
*             case 24: return '\u1F0B';
*             case 25: return '\u1F8B';
*             case 28: return '\u1F0F';
*             case 29: return '\u1F8F';
*             case 32: return '\u1F08';
*             case 33: return '\u1F88';
*             case 36: return '\u1F0C';
*             case 37: return '\u1F8C';
*             case 40: return '\u1F0A';
*             case 41: return '\u1F8A';
*             case 44: return '\u1F0E';
*             case 45: return '\u1F8E';
*             default: return '\u0391';
*         }
*     }
* largeEpsilon := text='[<>]?[\'`]?E'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1FC9';
*             case  8: return '\u1FC8';
*             case 16: return '\u1F19';
*             case 20: return '\u1F1D';
*             case 24: return '\u1F1B';
*             case 32: return '\u1F18';
*             case 36: return '\u1F1C';
*             case 40: return '\u1F1A';
*             default: return '\u0395';
*         }
*     }
*    
* largeEta := text='[<>]?[\'`~]?\^E\|?'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FCC';
*             case  4: return '\u1FCB';
*             // case  5: return '\uxxxx';
*             case  8: return '\u1FCA';
*             // case  9: return '\uxxxx';
*             // case 12: return '\uxxxx';
*             // case 13: return '\uxxxx';
*             case 16: return '\u1F29';
*             case 17: return '\u1F99';
*             case 20: return '\u1F2D';
*             case 21: return '\u1F9D';
*             case 24: return '\u1F2B';
*             case 25: return '\u1F9B';
*             case 28: return '\u1F2F';
*             case 29: return '\u1F9F';
*             case 32: return '\u1F28';
*             case 33: return '\u1F98';
*             case 36: return '\u1F2C';
*             case 37: return '\u1F9C';
*             case 40: return '\u1F2A';
*             case 41: return '\u1F9A';
*             case 44: return '\u1F2E';
*             case 45: return '\u1F9E';
*             default: return '\u0397';
*         }
*     }
* largeIota := text='[<>"]?[\'`~]?I'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1FDB';
*             case  8: return '\u1FDA';
*             // case  12: return '\uxxxx';
*             case 16: return '\u1F39';
*             case 20: return '\u1F3D';
*             case 24: return '\u1F3B';
*             case 28: return '\u1F3F';
*             case 32: return '\u1F38';
*             case 36: return '\u1F3C';
*             case 40: return '\u1F3A';
*             case 44: return '\u1F3E';
*             case 64: return '\u03AA';
*             default: return '\u0399';
*         }
*     }
* largeOmicron := text='[<>]?[\'`]?O'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1FF9';
*             case  8: return '\u1FF8';
*             case 16: return '\u1F49';
*             case 20: return '\u1F4D';
*             case 24: return '\u1F4B';
*             case 32: return '\u1F48';
*             case 36: return '\u1F4C';
*             case 40: return '\u1F4A';
*             default: return '\u039F';
*         }
*     }
* largeUpsilon := text='[<>"]?[\'`~]?[UY]'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1FEB';
*             case  8: return '\u1FEA';
*             // case  12: return '\uxxxx';
*             case 16: return '\u1F59';
*             case 20: return '\u1F5D';
*             case 24: return '\u1F5B';
*             case 28: return '\u1F5F';
*             case 64: return '\u03AB';
*             default: return '\u03A5';
*         }
*     }
* largeOmega := text='[<>]?[\'`~]?\^O\|?'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FFC';
*             case  4: return '\u1FFB';
*             // case  5: return '\uxxxx';
*             case  8: return '\u1FFA';
*             // case  9: return '\uxxxx';
*             // case 12: return '\uxxxx';
*             // case 13: return '\uxxxx';
*             case 16: return '\u1F69';
*             case 17: return '\u1FA9';
*             case 20: return '\u1F6D';
*             case 21: return '\u1FAD';
*             case 24: return '\u1F6B';
*             case 25: return '\u1FAB';
*             case 28: return '\u1F6F';
*             case 29: return '\u1FAF';
*             case 32: return '\u1F68';
*             case 33: return '\u1FA8';
*             case 36: return '\u1F6C';
*             case 37: return '\u1FAC';
*             case 40: return '\u1F6A';
*             case 41: return '\u1FAA';
*             case 44: return '\u1F6E';
*             case 45: return '\u1FAE';
*             default: return '\u03A9';
*         }
*     }
* largeBeta := text='B'
*     .value = string {
*         return '\u0392';
*     }
* largeGamma := text='G'
*     .value = string {
*         return '\u0393';
*     }
* largeDelta := text='D'
*     .value = string {
*         return '\u0394';
*     }
* largeZeta := text='Z'
*     .value = string {
*         return '\u0396';
*     }
* largeKappa := text='Kh?'
*     .value = string {
*         if (this.text.endsWith('h')) {
*             return '\u03A7';
*         } else {
*             return '\u039A';
*         }
*     }
* largeLambda := text='L'
*     .value = string {
*         return '\u039B';
*     }
* largeMu := text='M'
*     .value = string {
*         return '\u039C';
*     }
* largeNu :=
*       largeNasableGammaGamma
*     | largeNasableGammaKappa
*     | largeNasableGammaXi
*     | largeSingleNu
* largeNasableGammaGamma := 'N' suffix=largeGamma
*     .value = string {
*         return '\u0393' + this.suffix.value;
*     }
* largeNasableGammaKappa := 'N' suffix=largeKappa
*     .value = string {
*         return '\u0393' + this.suffix.value;
*     }
* largeNasableGammaXi := 'N' suffix=largeXi
*     .value = string {
*         return '\u0393' + this.suffix.value;
*     }
* largeSingleNu := text='N'
*     .value = string {
*         return '\u039D';
*     }
* largeXi := text='X'
*     .value = string {
*         return '\u039E';
*     }
* largePi := text='P[hs]?'
*     .value = string {
*         if (this.text.endsWith('h')) {
*             return '\u03A6';
*         } else if (this.text.endsWith('s')) {
*             return '\u03A8';
*         } else {
*             return '\u03A0';
*         }
*     }
* largeRho := text='<?R'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case 16: return '\u1FEC';
*             default: return '\u03A1';
*         }
*     }
* largeSigma := text='S'
*     .value = string {
*         return '\u03A3';
*     }
* largeTau := text='Th?'
*     .value = string {
*         if (this.text.endsWith('h')) {
*             return '\u0398';
*         } else {
*             return '\u03A4';
*         }
*     }
* smallAlpha := text='[<>]?[\'`~]?a\|?'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FB3';
*             case  4: return '\u1F71';
*             case  5: return '\u1FB4';
*             case  8: return '\u1F70';
*             case  9: return '\u1FB2';
*             case 12: return '\u1FB6';
*             case 13: return '\u1FB7';
*             case 16: return '\u1F01';
*             case 17: return '\u1F81';
*             case 20: return '\u1F05';
*             case 21: return '\u1F85';
*             case 24: return '\u1F03';
*             case 25: return '\u1F83';
*             case 28: return '\u1F07';
*             case 29: return '\u1F87';
*             case 32: return '\u1F00';
*             case 33: return '\u1F80';
*             case 36: return '\u1F04';
*             case 37: return '\u1F84';
*             case 40: return '\u1F02';
*             case 41: return '\u1F82';
*             case 44: return '\u1F06';
*             case 45: return '\u1F86';
*             default: return '\u03B1';
*         }
*     }
* smallEpsilon := text='[<>]?[\'`]?e'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1F73';
*             case  8: return '\u1F72';
*             case 16: return '\u1F11';
*             case 20: return '\u1F15';
*             case 24: return '\u1F13';
*             case 32: return '\u1F10';
*             case 36: return '\u1F14';
*             case 40: return '\u1F12';
*             default: return '\u03B5';
*         }
*     }
* smallEta := text='[<>]?[\'`~]?\^e\|?'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FC3';
*             case  4: return '\u1F75';
*             case  5: return '\u1FC4';
*             case  8: return '\u1F74';
*             case  9: return '\u1FC2';
*             case 12: return '\u1FC6';
*             case 13: return '\u1FC7';
*             case 16: return '\u1F21';
*             case 17: return '\u1F91';
*             case 20: return '\u1F25';
*             case 21: return '\u1F95';
*             case 24: return '\u1F23';
*             case 25: return '\u1F93';
*             case 28: return '\u1F27';
*             case 29: return '\u1F97';
*             case 32: return '\u1F20';
*             case 33: return '\u1F90';
*             case 36: return '\u1F24';
*             case 37: return '\u1F94';
*             case 40: return '\u1F22';
*             case 41: return '\u1F92';
*             case 44: return '\u1F26';
*             case 45: return '\u1F96';
*             default: return '\u03B7';
*         }
*     }
* smallIota := text='[<>"]?[\'`~]?i'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1F77';
*             case  8: return '\u1F76';
*             case 12: return '\u1FD6';
*             case 16: return '\u1F31';
*             case 20: return '\u1F35';
*             case 24: return '\u1F33';
*             case 28: return '\u1F37';
*             case 32: return '\u1F30';
*             case 36: return '\u1F34';
*             case 40: return '\u1F32';
*             case 44: return '\u1F36';
*             case 64: return '\u03CA';
*             case 68: return '\u1FD3';
*             case 72: return '\u1FD2';
*             case 76: return '\u1FD7';
*             default: return '\u03B9';
*         }
*     }
* smallOmicron := text='[<>]?[\'`]?o'
*     .value = string {
*     let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1F79';
*             case  8: return '\u1F78';
*             case 16: return '\u1F41';
*             case 20: return '\u1F45';
*             case 24: return '\u1F43';
*             case 32: return '\u1F40';
*             case 36: return '\u1F44';
*             case 40: return '\u1F42';
*             default: return '\u03BF';
*         }
*     }
* smallUpsilon := text='[<>"]?[\'`~]?[uy]'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case  4: return '\u1F7B';
*             case  8: return '\u1F7A';
*             case 12: return '\u1FE6';
*             case 16: return '\u1F51';
*             case 20: return '\u1F55';
*             case 24: return '\u1F53';
*             case 28: return '\u1F57';
*             case 32: return '\u1F50';
*             case 36: return '\u1F54';
*             case 40: return '\u1F52';
*             case 44: return '\u1F56';
*             case 64: return '\u03CB';
*             case 68: return '\u1FE3';
*             case 72: return '\u1FE2';
*             case 76: return '\u1FE7';
*             default: return '\u03C5';
*         }
*     }
* smallOmega := text='[<>]?[\'`~]?\^o\|?'
*     .value = string {
*         let score  = calcScore(this.text);
*         switch (score) {
*             case  1: return '\u1FF3';
*             case  4: return '\u1F7D';
*             case  5: return '\u1FF4';
*             case  8: return '\u1F7C';
*             case  9: return '\u1FF2';
*             case 12: return '\u1FF6';
*             case 13: return '\u1FF7';
*             case 16: return '\u1F61';
*             case 17: return '\u1FA1';
*             case 20: return '\u1F65';
*             case 21: return '\u1FA5';
*             case 24: return '\u1F63';
*             case 25: return '\u1FA3';
*             case 28: return '\u1F67';
*             case 29: return '\u1FA7';
*             case 32: return '\u1F60';
*             case 33: return '\u1FA0';
*             case 36: return '\u1F64';
*             case 37: return '\u1FA4';
*             case 40: return '\u1F62';
*             case 41: return '\u1FA2';
*             case 44: return '\u1F66';
*             case 45: return '\u1FA6';
*             default: return '\u03C9';
*         }
*     }
* smallBeta := text='b'
*     .value = string {
*         return '\u03B2';
*     }
* smallGamma := text='g'
*     .value = string {
*         return '\u03B3';
*     }
* smallDelta := text='d'
*     .value = string {
*         return '\u03B4';
*     }
* smallZeta := text='z'
*     .value = string {
*         return '\u03B6';
*     }
* smallKappa := text='kh?'
*     .value = string {
*         if (this.text.endsWith("h")) {
*             return '\u03C7';
*         } else {
*             return '\u03BA';
*         }
*     }
* smallLambda := text='l'
*     .value = string {
*         return '\u03BB';
*     }
* smallMu := text='m'
*     .value = string {
*         return '\u03BC';
*     }
* smallNu :=
*       smallNasableGammaGamma
*     | smallNasableGammaKappa
*     | smallNasableGammaXi
*     | smallSingleNu
* smallNasableGammaGamma := 'n' suffix=smallGamma
*     .value = string {
*         return '\u03B3' + this.suffix.value;
*     }
* smallNasableGammaKappa := 'n' suffix=smallKappa
*     .value = string {
*         return '\u03B3' + this.suffix.value;
*     }
* smallNasableGammaXi := 'n' suffix=smallXi
*     .value = string {
*         return '\u03B3' + this.suffix.value;
*     }
* smallSingleNu := text='n'
*     .value = string {
*         return '\u03BD';
*     }
* smallXi := text='x'
*     .value = string {
*         return '\u03BE';
*     }
* smallPi := text='p[hs]?'
*     .value = string {
*         if (this.text.includes("h")) {
*             return '\u03C6';
*         } else if (this.text.includes("s")) {
*             return '\u03C8';
*         } else {
*             return '\u03C0';
*         }
*     }
* smallRho := text='[<>]?r'
*     .value = string {
*         let score = calcScore(this.text);
*         switch (score) {
*             case 16: return '\u1FE5';
*             case 32: return '\u1FE4';
*             default: return '\u03C1';
*         }
*     }
* smallSigma :=
*       smallLeadingSigma
*     | smallSingleSigma
* smallLeadingSigma := 's' child=alphabet
*     .value = string {
*         return '\u03C3' + this.child.value;
*     }
* smallSingleSigma := text='[cs]'
*     .value = string {
*         if (text == "s") {
*             return '\u03C2';
*         } else {
*             return '\u03C3';
*         }
*     }
* smallTau := text='th?'
*     .value = string {
*         if (this.text.includes("h")) {
*             return '\u03B8';
*         } else {
*             return '\u03C4';
*         }
*     }
* punctuation :=
*       semicoron
*     | question
* semicoron := text=';'
*     .value = string {
*         return '\u0387';
*     }
* question := text='\?'
*     .value = string {
*         return '\u037E';
*     }
* anyChar := text='.'
*     .value = string {
*         return text;
*     }
*/

function calcScore(text: string): number {
    return addScoreDialesis(text,
            addScoreBreath(text,
            addScoreAccent(text,
            addScoreIotaSubscriptum(text))));
}

function addScoreDialesis(text: string, score=0): number {
    if (text.includes('"')) {
        return 4 ** 3 + score;
    } else {
        return score;
    }
}

function addScoreBreath(text: string, score=0): number {
    if (text.includes('<')) {
        return 4 ** 2 * 1 + score;
    } else if (text.includes('>')) {
        return 4 ** 2 * 2 + score;
    } else {
        return score;
    }
}

function addScoreAccent(text: string, score=0): number {
    if (text.includes("'")) {
        return 4 ** 1 * 1 + score;
    } else if (text.includes('\`')) {
        return 4 ** 1 * 2 + score;
    } else if (text.includes('~')) {
        return 4 ** 1 * 3 + score;
    } else {
        return score;
    }
}

function addScoreIotaSubscriptum(text: string, score=0): number {
    if (text.includes('|')) {
        return 1 + score;
    } else {
        return score;
    }
}

type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    letters = "letters",
    letter_1 = "letter_1",
    letter_2 = "letter_2",
    letter_3 = "letter_3",
    alphabet_1 = "alphabet_1",
    alphabet_2 = "alphabet_2",
    alphabet_3 = "alphabet_3",
    alphabet_4 = "alphabet_4",
    alphabet_5 = "alphabet_5",
    alphabet_6 = "alphabet_6",
    alphabet_7 = "alphabet_7",
    alphabet_8 = "alphabet_8",
    alphabet_9 = "alphabet_9",
    alphabet_10 = "alphabet_10",
    alphabet_11 = "alphabet_11",
    alphabet_12 = "alphabet_12",
    alphabet_13 = "alphabet_13",
    alphabet_14 = "alphabet_14",
    alphabet_15 = "alphabet_15",
    alphabet_16 = "alphabet_16",
    alphabet_17 = "alphabet_17",
    alphabet_18 = "alphabet_18",
    alphabet_19 = "alphabet_19",
    alphabet_20 = "alphabet_20",
    alphabet_21 = "alphabet_21",
    alphabet_22 = "alphabet_22",
    alphabet_23 = "alphabet_23",
    alphabet_24 = "alphabet_24",
    alphabet_25 = "alphabet_25",
    alphabet_26 = "alphabet_26",
    alphabet_27 = "alphabet_27",
    alphabet_28 = "alphabet_28",
    alphabet_29 = "alphabet_29",
    alphabet_30 = "alphabet_30",
    alphabet_31 = "alphabet_31",
    alphabet_32 = "alphabet_32",
    alphabet_33 = "alphabet_33",
    alphabet_34 = "alphabet_34",
    alphabet_35 = "alphabet_35",
    alphabet_36 = "alphabet_36",
    alphabet_37 = "alphabet_37",
    alphabet_38 = "alphabet_38",
    alphabet_39 = "alphabet_39",
    alphabet_40 = "alphabet_40",
    largeAlpha = "largeAlpha",
    largeEpsilon = "largeEpsilon",
    largeEta = "largeEta",
    largeIota = "largeIota",
    largeOmicron = "largeOmicron",
    largeUpsilon = "largeUpsilon",
    largeOmega = "largeOmega",
    largeBeta = "largeBeta",
    largeGamma = "largeGamma",
    largeDelta = "largeDelta",
    largeZeta = "largeZeta",
    largeKappa = "largeKappa",
    largeLambda = "largeLambda",
    largeMu = "largeMu",
    largeNu_1 = "largeNu_1",
    largeNu_2 = "largeNu_2",
    largeNu_3 = "largeNu_3",
    largeNu_4 = "largeNu_4",
    largeNasableGammaGamma = "largeNasableGammaGamma",
    largeNasableGammaKappa = "largeNasableGammaKappa",
    largeNasableGammaXi = "largeNasableGammaXi",
    largeSingleNu = "largeSingleNu",
    largeXi = "largeXi",
    largePi = "largePi",
    largeRho = "largeRho",
    largeSigma = "largeSigma",
    largeTau = "largeTau",
    smallAlpha = "smallAlpha",
    smallEpsilon = "smallEpsilon",
    smallEta = "smallEta",
    smallIota = "smallIota",
    smallOmicron = "smallOmicron",
    smallUpsilon = "smallUpsilon",
    smallOmega = "smallOmega",
    smallBeta = "smallBeta",
    smallGamma = "smallGamma",
    smallDelta = "smallDelta",
    smallZeta = "smallZeta",
    smallKappa = "smallKappa",
    smallLambda = "smallLambda",
    smallMu = "smallMu",
    smallNu_1 = "smallNu_1",
    smallNu_2 = "smallNu_2",
    smallNu_3 = "smallNu_3",
    smallNu_4 = "smallNu_4",
    smallNasableGammaGamma = "smallNasableGammaGamma",
    smallNasableGammaKappa = "smallNasableGammaKappa",
    smallNasableGammaXi = "smallNasableGammaXi",
    smallSingleNu = "smallSingleNu",
    smallXi = "smallXi",
    smallPi = "smallPi",
    smallRho = "smallRho",
    smallSigma_1 = "smallSigma_1",
    smallSigma_2 = "smallSigma_2",
    smallLeadingSigma = "smallLeadingSigma",
    smallSingleSigma = "smallSingleSigma",
    smallTau = "smallTau",
    punctuation_1 = "punctuation_1",
    punctuation_2 = "punctuation_2",
    semicoron = "semicoron",
    question = "question",
    anyChar = "anyChar",
}
export class letters {
    public kind: ASTKinds.letters = ASTKinds.letters;
    public children: letter[];
    public value: string;
    constructor(children: letter[]){
        this.children = children;
        this.value = ((): string => {
        return this.children.map(l => l.value).join('');
        })();
    }
}
export type letter = letter_1 | letter_2 | letter_3;
export type letter_1 = alphabet;
export type letter_2 = punctuation;
export type letter_3 = anyChar;
export type alphabet = alphabet_1 | alphabet_2 | alphabet_3 | alphabet_4 | alphabet_5 | alphabet_6 | alphabet_7 | alphabet_8 | alphabet_9 | alphabet_10 | alphabet_11 | alphabet_12 | alphabet_13 | alphabet_14 | alphabet_15 | alphabet_16 | alphabet_17 | alphabet_18 | alphabet_19 | alphabet_20 | alphabet_21 | alphabet_22 | alphabet_23 | alphabet_24 | alphabet_25 | alphabet_26 | alphabet_27 | alphabet_28 | alphabet_29 | alphabet_30 | alphabet_31 | alphabet_32 | alphabet_33 | alphabet_34 | alphabet_35 | alphabet_36 | alphabet_37 | alphabet_38 | alphabet_39 | alphabet_40;
export type alphabet_1 = largeAlpha;
export type alphabet_2 = largeEpsilon;
export type alphabet_3 = largeEta;
export type alphabet_4 = largeIota;
export type alphabet_5 = largeOmicron;
export type alphabet_6 = largeUpsilon;
export type alphabet_7 = largeOmega;
export type alphabet_8 = largeBeta;
export type alphabet_9 = largeGamma;
export type alphabet_10 = largeDelta;
export type alphabet_11 = largeZeta;
export type alphabet_12 = largeKappa;
export type alphabet_13 = largeLambda;
export type alphabet_14 = largeMu;
export type alphabet_15 = largeNu;
export type alphabet_16 = largeXi;
export type alphabet_17 = largePi;
export type alphabet_18 = largeRho;
export type alphabet_19 = largeSigma;
export type alphabet_20 = largeTau;
export type alphabet_21 = smallAlpha;
export type alphabet_22 = smallEpsilon;
export type alphabet_23 = smallEta;
export type alphabet_24 = smallIota;
export type alphabet_25 = smallOmicron;
export type alphabet_26 = smallUpsilon;
export type alphabet_27 = smallOmega;
export type alphabet_28 = smallBeta;
export type alphabet_29 = smallGamma;
export type alphabet_30 = smallDelta;
export type alphabet_31 = smallZeta;
export type alphabet_32 = smallKappa;
export type alphabet_33 = smallLambda;
export type alphabet_34 = smallMu;
export type alphabet_35 = smallNu;
export type alphabet_36 = smallXi;
export type alphabet_37 = smallPi;
export type alphabet_38 = smallRho;
export type alphabet_39 = smallSigma;
export type alphabet_40 = smallTau;
export class largeAlpha {
    public kind: ASTKinds.largeAlpha = ASTKinds.largeAlpha;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FBC';
            case  4: return '\u1FBB';
            // case  5: return '\uxxxx';
            case  8: return '\u1FBA';
            // case  9: return '\uxxxx';
            // case 12: return '\uxxxx';
            // case 13: return '\uxxxx';
            case 16: return '\u1F09';
            case 17: return '\u1F89';
            case 20: return '\u1F0D';
            case 21: return '\u1F8D';
            case 24: return '\u1F0B';
            case 25: return '\u1F8B';
            case 28: return '\u1F0F';
            case 29: return '\u1F8F';
            case 32: return '\u1F08';
            case 33: return '\u1F88';
            case 36: return '\u1F0C';
            case 37: return '\u1F8C';
            case 40: return '\u1F0A';
            case 41: return '\u1F8A';
            case 44: return '\u1F0E';
            case 45: return '\u1F8E';
            default: return '\u0391';
        }
        })();
    }
}
export class largeEpsilon {
    public kind: ASTKinds.largeEpsilon = ASTKinds.largeEpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1FC9';
            case  8: return '\u1FC8';
            case 16: return '\u1F19';
            case 20: return '\u1F1D';
            case 24: return '\u1F1B';
            case 32: return '\u1F18';
            case 36: return '\u1F1C';
            case 40: return '\u1F1A';
            default: return '\u0395';
        }
        })();
    }
}
export class largeEta {
    public kind: ASTKinds.largeEta = ASTKinds.largeEta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FCC';
            case  4: return '\u1FCB';
            // case  5: return '\uxxxx';
            case  8: return '\u1FCA';
            // case  9: return '\uxxxx';
            // case 12: return '\uxxxx';
            // case 13: return '\uxxxx';
            case 16: return '\u1F29';
            case 17: return '\u1F99';
            case 20: return '\u1F2D';
            case 21: return '\u1F9D';
            case 24: return '\u1F2B';
            case 25: return '\u1F9B';
            case 28: return '\u1F2F';
            case 29: return '\u1F9F';
            case 32: return '\u1F28';
            case 33: return '\u1F98';
            case 36: return '\u1F2C';
            case 37: return '\u1F9C';
            case 40: return '\u1F2A';
            case 41: return '\u1F9A';
            case 44: return '\u1F2E';
            case 45: return '\u1F9E';
            default: return '\u0397';
        }
        })();
    }
}
export class largeIota {
    public kind: ASTKinds.largeIota = ASTKinds.largeIota;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1FDB';
            case  8: return '\u1FDA';
            // case  12: return '\uxxxx';
            case 16: return '\u1F39';
            case 20: return '\u1F3D';
            case 24: return '\u1F3B';
            case 28: return '\u1F3F';
            case 32: return '\u1F38';
            case 36: return '\u1F3C';
            case 40: return '\u1F3A';
            case 44: return '\u1F3E';
            case 64: return '\u03AA';
            default: return '\u0399';
        }
        })();
    }
}
export class largeOmicron {
    public kind: ASTKinds.largeOmicron = ASTKinds.largeOmicron;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1FF9';
            case  8: return '\u1FF8';
            case 16: return '\u1F49';
            case 20: return '\u1F4D';
            case 24: return '\u1F4B';
            case 32: return '\u1F48';
            case 36: return '\u1F4C';
            case 40: return '\u1F4A';
            default: return '\u039F';
        }
        })();
    }
}
export class largeUpsilon {
    public kind: ASTKinds.largeUpsilon = ASTKinds.largeUpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1FEB';
            case  8: return '\u1FEA';
            // case  12: return '\uxxxx';
            case 16: return '\u1F59';
            case 20: return '\u1F5D';
            case 24: return '\u1F5B';
            case 28: return '\u1F5F';
            case 64: return '\u03AB';
            default: return '\u03A5';
        }
        })();
    }
}
export class largeOmega {
    public kind: ASTKinds.largeOmega = ASTKinds.largeOmega;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FFC';
            case  4: return '\u1FFB';
            // case  5: return '\uxxxx';
            case  8: return '\u1FFA';
            // case  9: return '\uxxxx';
            // case 12: return '\uxxxx';
            // case 13: return '\uxxxx';
            case 16: return '\u1F69';
            case 17: return '\u1FA9';
            case 20: return '\u1F6D';
            case 21: return '\u1FAD';
            case 24: return '\u1F6B';
            case 25: return '\u1FAB';
            case 28: return '\u1F6F';
            case 29: return '\u1FAF';
            case 32: return '\u1F68';
            case 33: return '\u1FA8';
            case 36: return '\u1F6C';
            case 37: return '\u1FAC';
            case 40: return '\u1F6A';
            case 41: return '\u1FAA';
            case 44: return '\u1F6E';
            case 45: return '\u1FAE';
            default: return '\u03A9';
        }
        })();
    }
}
export class largeBeta {
    public kind: ASTKinds.largeBeta = ASTKinds.largeBeta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u0392';
        })();
    }
}
export class largeGamma {
    public kind: ASTKinds.largeGamma = ASTKinds.largeGamma;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u0393';
        })();
    }
}
export class largeDelta {
    public kind: ASTKinds.largeDelta = ASTKinds.largeDelta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u0394';
        })();
    }
}
export class largeZeta {
    public kind: ASTKinds.largeZeta = ASTKinds.largeZeta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u0396';
        })();
    }
}
export class largeKappa {
    public kind: ASTKinds.largeKappa = ASTKinds.largeKappa;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.endsWith('h')) {
            return '\u03A7';
        } else {
            return '\u039A';
        }
        })();
    }
}
export class largeLambda {
    public kind: ASTKinds.largeLambda = ASTKinds.largeLambda;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u039B';
        })();
    }
}
export class largeMu {
    public kind: ASTKinds.largeMu = ASTKinds.largeMu;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u039C';
        })();
    }
}
export type largeNu = largeNu_1 | largeNu_2 | largeNu_3 | largeNu_4;
export type largeNu_1 = largeNasableGammaGamma;
export type largeNu_2 = largeNasableGammaKappa;
export type largeNu_3 = largeNasableGammaXi;
export type largeNu_4 = largeSingleNu;
export class largeNasableGammaGamma {
    public kind: ASTKinds.largeNasableGammaGamma = ASTKinds.largeNasableGammaGamma;
    public suffix: largeGamma;
    public value: string;
    constructor(suffix: largeGamma){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u0393' + this.suffix.value;
        })();
    }
}
export class largeNasableGammaKappa {
    public kind: ASTKinds.largeNasableGammaKappa = ASTKinds.largeNasableGammaKappa;
    public suffix: largeKappa;
    public value: string;
    constructor(suffix: largeKappa){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u0393' + this.suffix.value;
        })();
    }
}
export class largeNasableGammaXi {
    public kind: ASTKinds.largeNasableGammaXi = ASTKinds.largeNasableGammaXi;
    public suffix: largeXi;
    public value: string;
    constructor(suffix: largeXi){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u0393' + this.suffix.value;
        })();
    }
}
export class largeSingleNu {
    public kind: ASTKinds.largeSingleNu = ASTKinds.largeSingleNu;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u039D';
        })();
    }
}
export class largeXi {
    public kind: ASTKinds.largeXi = ASTKinds.largeXi;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u039E';
        })();
    }
}
export class largePi {
    public kind: ASTKinds.largePi = ASTKinds.largePi;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.endsWith('h')) {
            return '\u03A6';
        } else if (this.text.endsWith('s')) {
            return '\u03A8';
        } else {
            return '\u03A0';
        }
        })();
    }
}
export class largeRho {
    public kind: ASTKinds.largeRho = ASTKinds.largeRho;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case 16: return '\u1FEC';
            default: return '\u03A1';
        }
        })();
    }
}
export class largeSigma {
    public kind: ASTKinds.largeSigma = ASTKinds.largeSigma;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03A3';
        })();
    }
}
export class largeTau {
    public kind: ASTKinds.largeTau = ASTKinds.largeTau;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.endsWith('h')) {
            return '\u0398';
        } else {
            return '\u03A4';
        }
        })();
    }
}
export class smallAlpha {
    public kind: ASTKinds.smallAlpha = ASTKinds.smallAlpha;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FB3';
            case  4: return '\u1F71';
            case  5: return '\u1FB4';
            case  8: return '\u1F70';
            case  9: return '\u1FB2';
            case 12: return '\u1FB6';
            case 13: return '\u1FB7';
            case 16: return '\u1F01';
            case 17: return '\u1F81';
            case 20: return '\u1F05';
            case 21: return '\u1F85';
            case 24: return '\u1F03';
            case 25: return '\u1F83';
            case 28: return '\u1F07';
            case 29: return '\u1F87';
            case 32: return '\u1F00';
            case 33: return '\u1F80';
            case 36: return '\u1F04';
            case 37: return '\u1F84';
            case 40: return '\u1F02';
            case 41: return '\u1F82';
            case 44: return '\u1F06';
            case 45: return '\u1F86';
            default: return '\u03B1';
        }
        })();
    }
}
export class smallEpsilon {
    public kind: ASTKinds.smallEpsilon = ASTKinds.smallEpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1F73';
            case  8: return '\u1F72';
            case 16: return '\u1F11';
            case 20: return '\u1F15';
            case 24: return '\u1F13';
            case 32: return '\u1F10';
            case 36: return '\u1F14';
            case 40: return '\u1F12';
            default: return '\u03B5';
        }
        })();
    }
}
export class smallEta {
    public kind: ASTKinds.smallEta = ASTKinds.smallEta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FC3';
            case  4: return '\u1F75';
            case  5: return '\u1FC4';
            case  8: return '\u1F74';
            case  9: return '\u1FC2';
            case 12: return '\u1FC6';
            case 13: return '\u1FC7';
            case 16: return '\u1F21';
            case 17: return '\u1F91';
            case 20: return '\u1F25';
            case 21: return '\u1F95';
            case 24: return '\u1F23';
            case 25: return '\u1F93';
            case 28: return '\u1F27';
            case 29: return '\u1F97';
            case 32: return '\u1F20';
            case 33: return '\u1F90';
            case 36: return '\u1F24';
            case 37: return '\u1F94';
            case 40: return '\u1F22';
            case 41: return '\u1F92';
            case 44: return '\u1F26';
            case 45: return '\u1F96';
            default: return '\u03B7';
        }
        })();
    }
}
export class smallIota {
    public kind: ASTKinds.smallIota = ASTKinds.smallIota;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1F77';
            case  8: return '\u1F76';
            case 12: return '\u1FD6';
            case 16: return '\u1F31';
            case 20: return '\u1F35';
            case 24: return '\u1F33';
            case 28: return '\u1F37';
            case 32: return '\u1F30';
            case 36: return '\u1F34';
            case 40: return '\u1F32';
            case 44: return '\u1F36';
            case 64: return '\u03CA';
            case 68: return '\u1FD3';
            case 72: return '\u1FD2';
            case 76: return '\u1FD7';
            default: return '\u03B9';
        }
        })();
    }
}
export class smallOmicron {
    public kind: ASTKinds.smallOmicron = ASTKinds.smallOmicron;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1F79';
            case  8: return '\u1F78';
            case 16: return '\u1F41';
            case 20: return '\u1F45';
            case 24: return '\u1F43';
            case 32: return '\u1F40';
            case 36: return '\u1F44';
            case 40: return '\u1F42';
            default: return '\u03BF';
        }
        })();
    }
}
export class smallUpsilon {
    public kind: ASTKinds.smallUpsilon = ASTKinds.smallUpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case  4: return '\u1F7B';
            case  8: return '\u1F7A';
            case 12: return '\u1FE6';
            case 16: return '\u1F51';
            case 20: return '\u1F55';
            case 24: return '\u1F53';
            case 28: return '\u1F57';
            case 32: return '\u1F50';
            case 36: return '\u1F54';
            case 40: return '\u1F52';
            case 44: return '\u1F56';
            case 64: return '\u03CB';
            case 68: return '\u1FE3';
            case 72: return '\u1FE2';
            case 76: return '\u1FE7';
            default: return '\u03C5';
        }
        })();
    }
}
export class smallOmega {
    public kind: ASTKinds.smallOmega = ASTKinds.smallOmega;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score  = calcScore(this.text);
        switch (score) {
            case  1: return '\u1FF3';
            case  4: return '\u1F7D';
            case  5: return '\u1FF4';
            case  8: return '\u1F7C';
            case  9: return '\u1FF2';
            case 12: return '\u1FF6';
            case 13: return '\u1FF7';
            case 16: return '\u1F61';
            case 17: return '\u1FA1';
            case 20: return '\u1F65';
            case 21: return '\u1FA5';
            case 24: return '\u1F63';
            case 25: return '\u1FA3';
            case 28: return '\u1F67';
            case 29: return '\u1FA7';
            case 32: return '\u1F60';
            case 33: return '\u1FA0';
            case 36: return '\u1F64';
            case 37: return '\u1FA4';
            case 40: return '\u1F62';
            case 41: return '\u1FA2';
            case 44: return '\u1F66';
            case 45: return '\u1FA6';
            default: return '\u03C9';
        }
        })();
    }
}
export class smallBeta {
    public kind: ASTKinds.smallBeta = ASTKinds.smallBeta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03B2';
        })();
    }
}
export class smallGamma {
    public kind: ASTKinds.smallGamma = ASTKinds.smallGamma;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03B3';
        })();
    }
}
export class smallDelta {
    public kind: ASTKinds.smallDelta = ASTKinds.smallDelta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03B4';
        })();
    }
}
export class smallZeta {
    public kind: ASTKinds.smallZeta = ASTKinds.smallZeta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03B6';
        })();
    }
}
export class smallKappa {
    public kind: ASTKinds.smallKappa = ASTKinds.smallKappa;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.endsWith("h")) {
            return '\u03C7';
        } else {
            return '\u03BA';
        }
        })();
    }
}
export class smallLambda {
    public kind: ASTKinds.smallLambda = ASTKinds.smallLambda;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03BB';
        })();
    }
}
export class smallMu {
    public kind: ASTKinds.smallMu = ASTKinds.smallMu;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03BC';
        })();
    }
}
export type smallNu = smallNu_1 | smallNu_2 | smallNu_3 | smallNu_4;
export type smallNu_1 = smallNasableGammaGamma;
export type smallNu_2 = smallNasableGammaKappa;
export type smallNu_3 = smallNasableGammaXi;
export type smallNu_4 = smallSingleNu;
export class smallNasableGammaGamma {
    public kind: ASTKinds.smallNasableGammaGamma = ASTKinds.smallNasableGammaGamma;
    public suffix: smallGamma;
    public value: string;
    constructor(suffix: smallGamma){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u03B3' + this.suffix.value;
        })();
    }
}
export class smallNasableGammaKappa {
    public kind: ASTKinds.smallNasableGammaKappa = ASTKinds.smallNasableGammaKappa;
    public suffix: smallKappa;
    public value: string;
    constructor(suffix: smallKappa){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u03B3' + this.suffix.value;
        })();
    }
}
export class smallNasableGammaXi {
    public kind: ASTKinds.smallNasableGammaXi = ASTKinds.smallNasableGammaXi;
    public suffix: smallXi;
    public value: string;
    constructor(suffix: smallXi){
        this.suffix = suffix;
        this.value = ((): string => {
        return '\u03B3' + this.suffix.value;
        })();
    }
}
export class smallSingleNu {
    public kind: ASTKinds.smallSingleNu = ASTKinds.smallSingleNu;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03BD';
        })();
    }
}
export class smallXi {
    public kind: ASTKinds.smallXi = ASTKinds.smallXi;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u03BE';
        })();
    }
}
export class smallPi {
    public kind: ASTKinds.smallPi = ASTKinds.smallPi;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.includes("h")) {
            return '\u03C6';
        } else if (this.text.includes("s")) {
            return '\u03C8';
        } else {
            return '\u03C0';
        }
        })();
    }
}
export class smallRho {
    public kind: ASTKinds.smallRho = ASTKinds.smallRho;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        let score = calcScore(this.text);
        switch (score) {
            case 16: return '\u1FE5';
            case 32: return '\u1FE4';
            default: return '\u03C1';
        }
        })();
    }
}
export type smallSigma = smallSigma_1 | smallSigma_2;
export type smallSigma_1 = smallLeadingSigma;
export type smallSigma_2 = smallSingleSigma;
export class smallLeadingSigma {
    public kind: ASTKinds.smallLeadingSigma = ASTKinds.smallLeadingSigma;
    public child: alphabet;
    public value: string;
    constructor(child: alphabet){
        this.child = child;
        this.value = ((): string => {
        return '\u03C3' + this.child.value;
        })();
    }
}
export class smallSingleSigma {
    public kind: ASTKinds.smallSingleSigma = ASTKinds.smallSingleSigma;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (text == "s") {
            return '\u03C2';
        } else {
            return '\u03C3';
        }
        })();
    }
}
export class smallTau {
    public kind: ASTKinds.smallTau = ASTKinds.smallTau;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        if (this.text.includes("h")) {
            return '\u03B8';
        } else {
            return '\u03C4';
        }
        })();
    }
}
export type punctuation = punctuation_1 | punctuation_2;
export type punctuation_1 = semicoron;
export type punctuation_2 = question;
export class semicoron {
    public kind: ASTKinds.semicoron = ASTKinds.semicoron;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u0387';
        })();
    }
}
export class question {
    public kind: ASTKinds.question = ASTKinds.question;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '\u037E';
        })();
    }
}
export class anyChar {
    public kind: ASTKinds.anyChar = ASTKinds.anyChar;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchletters($$dpth: number, $$cr?: ErrorTracker): Nullable<letters> {
        return this.run<letters>($$dpth,
            () => {
                let $scope$children: Nullable<letter[]>;
                let $$res: Nullable<letters> = null;
                if (true
                    && ($scope$children = this.loop<letter>(() => this.matchletter($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = new letters($scope$children);
                }
                return $$res;
            });
    }
    public matchletter($$dpth: number, $$cr?: ErrorTracker): Nullable<letter> {
        return this.choice<letter>([
            () => this.matchletter_1($$dpth + 1, $$cr),
            () => this.matchletter_2($$dpth + 1, $$cr),
            () => this.matchletter_3($$dpth + 1, $$cr),
        ]);
    }
    public matchletter_1($$dpth: number, $$cr?: ErrorTracker): Nullable<letter_1> {
        return this.matchalphabet($$dpth + 1, $$cr);
    }
    public matchletter_2($$dpth: number, $$cr?: ErrorTracker): Nullable<letter_2> {
        return this.matchpunctuation($$dpth + 1, $$cr);
    }
    public matchletter_3($$dpth: number, $$cr?: ErrorTracker): Nullable<letter_3> {
        return this.matchanyChar($$dpth + 1, $$cr);
    }
    public matchalphabet($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet> {
        return this.choice<alphabet>([
            () => this.matchalphabet_1($$dpth + 1, $$cr),
            () => this.matchalphabet_2($$dpth + 1, $$cr),
            () => this.matchalphabet_3($$dpth + 1, $$cr),
            () => this.matchalphabet_4($$dpth + 1, $$cr),
            () => this.matchalphabet_5($$dpth + 1, $$cr),
            () => this.matchalphabet_6($$dpth + 1, $$cr),
            () => this.matchalphabet_7($$dpth + 1, $$cr),
            () => this.matchalphabet_8($$dpth + 1, $$cr),
            () => this.matchalphabet_9($$dpth + 1, $$cr),
            () => this.matchalphabet_10($$dpth + 1, $$cr),
            () => this.matchalphabet_11($$dpth + 1, $$cr),
            () => this.matchalphabet_12($$dpth + 1, $$cr),
            () => this.matchalphabet_13($$dpth + 1, $$cr),
            () => this.matchalphabet_14($$dpth + 1, $$cr),
            () => this.matchalphabet_15($$dpth + 1, $$cr),
            () => this.matchalphabet_16($$dpth + 1, $$cr),
            () => this.matchalphabet_17($$dpth + 1, $$cr),
            () => this.matchalphabet_18($$dpth + 1, $$cr),
            () => this.matchalphabet_19($$dpth + 1, $$cr),
            () => this.matchalphabet_20($$dpth + 1, $$cr),
            () => this.matchalphabet_21($$dpth + 1, $$cr),
            () => this.matchalphabet_22($$dpth + 1, $$cr),
            () => this.matchalphabet_23($$dpth + 1, $$cr),
            () => this.matchalphabet_24($$dpth + 1, $$cr),
            () => this.matchalphabet_25($$dpth + 1, $$cr),
            () => this.matchalphabet_26($$dpth + 1, $$cr),
            () => this.matchalphabet_27($$dpth + 1, $$cr),
            () => this.matchalphabet_28($$dpth + 1, $$cr),
            () => this.matchalphabet_29($$dpth + 1, $$cr),
            () => this.matchalphabet_30($$dpth + 1, $$cr),
            () => this.matchalphabet_31($$dpth + 1, $$cr),
            () => this.matchalphabet_32($$dpth + 1, $$cr),
            () => this.matchalphabet_33($$dpth + 1, $$cr),
            () => this.matchalphabet_34($$dpth + 1, $$cr),
            () => this.matchalphabet_35($$dpth + 1, $$cr),
            () => this.matchalphabet_36($$dpth + 1, $$cr),
            () => this.matchalphabet_37($$dpth + 1, $$cr),
            () => this.matchalphabet_38($$dpth + 1, $$cr),
            () => this.matchalphabet_39($$dpth + 1, $$cr),
            () => this.matchalphabet_40($$dpth + 1, $$cr),
        ]);
    }
    public matchalphabet_1($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_1> {
        return this.matchlargeAlpha($$dpth + 1, $$cr);
    }
    public matchalphabet_2($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_2> {
        return this.matchlargeEpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_3($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_3> {
        return this.matchlargeEta($$dpth + 1, $$cr);
    }
    public matchalphabet_4($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_4> {
        return this.matchlargeIota($$dpth + 1, $$cr);
    }
    public matchalphabet_5($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_5> {
        return this.matchlargeOmicron($$dpth + 1, $$cr);
    }
    public matchalphabet_6($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_6> {
        return this.matchlargeUpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_7($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_7> {
        return this.matchlargeOmega($$dpth + 1, $$cr);
    }
    public matchalphabet_8($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_8> {
        return this.matchlargeBeta($$dpth + 1, $$cr);
    }
    public matchalphabet_9($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_9> {
        return this.matchlargeGamma($$dpth + 1, $$cr);
    }
    public matchalphabet_10($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_10> {
        return this.matchlargeDelta($$dpth + 1, $$cr);
    }
    public matchalphabet_11($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_11> {
        return this.matchlargeZeta($$dpth + 1, $$cr);
    }
    public matchalphabet_12($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_12> {
        return this.matchlargeKappa($$dpth + 1, $$cr);
    }
    public matchalphabet_13($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_13> {
        return this.matchlargeLambda($$dpth + 1, $$cr);
    }
    public matchalphabet_14($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_14> {
        return this.matchlargeMu($$dpth + 1, $$cr);
    }
    public matchalphabet_15($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_15> {
        return this.matchlargeNu($$dpth + 1, $$cr);
    }
    public matchalphabet_16($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_16> {
        return this.matchlargeXi($$dpth + 1, $$cr);
    }
    public matchalphabet_17($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_17> {
        return this.matchlargePi($$dpth + 1, $$cr);
    }
    public matchalphabet_18($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_18> {
        return this.matchlargeRho($$dpth + 1, $$cr);
    }
    public matchalphabet_19($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_19> {
        return this.matchlargeSigma($$dpth + 1, $$cr);
    }
    public matchalphabet_20($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_20> {
        return this.matchlargeTau($$dpth + 1, $$cr);
    }
    public matchalphabet_21($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_21> {
        return this.matchsmallAlpha($$dpth + 1, $$cr);
    }
    public matchalphabet_22($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_22> {
        return this.matchsmallEpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_23($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_23> {
        return this.matchsmallEta($$dpth + 1, $$cr);
    }
    public matchalphabet_24($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_24> {
        return this.matchsmallIota($$dpth + 1, $$cr);
    }
    public matchalphabet_25($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_25> {
        return this.matchsmallOmicron($$dpth + 1, $$cr);
    }
    public matchalphabet_26($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_26> {
        return this.matchsmallUpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_27($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_27> {
        return this.matchsmallOmega($$dpth + 1, $$cr);
    }
    public matchalphabet_28($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_28> {
        return this.matchsmallBeta($$dpth + 1, $$cr);
    }
    public matchalphabet_29($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_29> {
        return this.matchsmallGamma($$dpth + 1, $$cr);
    }
    public matchalphabet_30($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_30> {
        return this.matchsmallDelta($$dpth + 1, $$cr);
    }
    public matchalphabet_31($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_31> {
        return this.matchsmallZeta($$dpth + 1, $$cr);
    }
    public matchalphabet_32($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_32> {
        return this.matchsmallKappa($$dpth + 1, $$cr);
    }
    public matchalphabet_33($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_33> {
        return this.matchsmallLambda($$dpth + 1, $$cr);
    }
    public matchalphabet_34($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_34> {
        return this.matchsmallMu($$dpth + 1, $$cr);
    }
    public matchalphabet_35($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_35> {
        return this.matchsmallNu($$dpth + 1, $$cr);
    }
    public matchalphabet_36($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_36> {
        return this.matchsmallXi($$dpth + 1, $$cr);
    }
    public matchalphabet_37($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_37> {
        return this.matchsmallPi($$dpth + 1, $$cr);
    }
    public matchalphabet_38($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_38> {
        return this.matchsmallRho($$dpth + 1, $$cr);
    }
    public matchalphabet_39($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_39> {
        return this.matchsmallSigma($$dpth + 1, $$cr);
    }
    public matchalphabet_40($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_40> {
        return this.matchsmallTau($$dpth + 1, $$cr);
    }
    public matchlargeAlpha($$dpth: number, $$cr?: ErrorTracker): Nullable<largeAlpha> {
        return this.run<largeAlpha>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeAlpha> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?A\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeAlpha($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeEpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<largeEpsilon> {
        return this.run<largeEpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeEpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`]?E)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeEpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeEta($$dpth: number, $$cr?: ErrorTracker): Nullable<largeEta> {
        return this.run<largeEta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeEta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?\^E\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeEta($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeIota($$dpth: number, $$cr?: ErrorTracker): Nullable<largeIota> {
        return this.run<largeIota>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeIota> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>"]?[\'\`~]?I)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeIota($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeOmicron($$dpth: number, $$cr?: ErrorTracker): Nullable<largeOmicron> {
        return this.run<largeOmicron>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeOmicron> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`]?O)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeOmicron($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeUpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<largeUpsilon> {
        return this.run<largeUpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeUpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>"]?[\'\`~]?[UY])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeUpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeOmega($$dpth: number, $$cr?: ErrorTracker): Nullable<largeOmega> {
        return this.run<largeOmega>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeOmega> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?\^O\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeOmega($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeBeta($$dpth: number, $$cr?: ErrorTracker): Nullable<largeBeta> {
        return this.run<largeBeta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeBeta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:B)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeBeta($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeGamma($$dpth: number, $$cr?: ErrorTracker): Nullable<largeGamma> {
        return this.run<largeGamma>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeGamma> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:G)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeGamma($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeDelta($$dpth: number, $$cr?: ErrorTracker): Nullable<largeDelta> {
        return this.run<largeDelta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeDelta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:D)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeDelta($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeZeta($$dpth: number, $$cr?: ErrorTracker): Nullable<largeZeta> {
        return this.run<largeZeta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeZeta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:Z)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeZeta($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeKappa($$dpth: number, $$cr?: ErrorTracker): Nullable<largeKappa> {
        return this.run<largeKappa>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeKappa> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:Kh?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeKappa($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeLambda($$dpth: number, $$cr?: ErrorTracker): Nullable<largeLambda> {
        return this.run<largeLambda>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeLambda> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:L)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeLambda($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeMu($$dpth: number, $$cr?: ErrorTracker): Nullable<largeMu> {
        return this.run<largeMu>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeMu> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:M)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeMu($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeNu($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNu> {
        return this.choice<largeNu>([
            () => this.matchlargeNu_1($$dpth + 1, $$cr),
            () => this.matchlargeNu_2($$dpth + 1, $$cr),
            () => this.matchlargeNu_3($$dpth + 1, $$cr),
            () => this.matchlargeNu_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlargeNu_1($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNu_1> {
        return this.matchlargeNasableGammaGamma($$dpth + 1, $$cr);
    }
    public matchlargeNu_2($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNu_2> {
        return this.matchlargeNasableGammaKappa($$dpth + 1, $$cr);
    }
    public matchlargeNu_3($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNu_3> {
        return this.matchlargeNasableGammaXi($$dpth + 1, $$cr);
    }
    public matchlargeNu_4($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNu_4> {
        return this.matchlargeSingleNu($$dpth + 1, $$cr);
    }
    public matchlargeNasableGammaGamma($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNasableGammaGamma> {
        return this.run<largeNasableGammaGamma>($$dpth,
            () => {
                let $scope$suffix: Nullable<largeGamma>;
                let $$res: Nullable<largeNasableGammaGamma> = null;
                if (true
                    && this.regexAccept(String.raw`(?:N)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchlargeGamma($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeNasableGammaGamma($scope$suffix);
                }
                return $$res;
            });
    }
    public matchlargeNasableGammaKappa($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNasableGammaKappa> {
        return this.run<largeNasableGammaKappa>($$dpth,
            () => {
                let $scope$suffix: Nullable<largeKappa>;
                let $$res: Nullable<largeNasableGammaKappa> = null;
                if (true
                    && this.regexAccept(String.raw`(?:N)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchlargeKappa($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeNasableGammaKappa($scope$suffix);
                }
                return $$res;
            });
    }
    public matchlargeNasableGammaXi($$dpth: number, $$cr?: ErrorTracker): Nullable<largeNasableGammaXi> {
        return this.run<largeNasableGammaXi>($$dpth,
            () => {
                let $scope$suffix: Nullable<largeXi>;
                let $$res: Nullable<largeNasableGammaXi> = null;
                if (true
                    && this.regexAccept(String.raw`(?:N)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchlargeXi($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeNasableGammaXi($scope$suffix);
                }
                return $$res;
            });
    }
    public matchlargeSingleNu($$dpth: number, $$cr?: ErrorTracker): Nullable<largeSingleNu> {
        return this.run<largeSingleNu>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeSingleNu> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:N)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeSingleNu($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeXi($$dpth: number, $$cr?: ErrorTracker): Nullable<largeXi> {
        return this.run<largeXi>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeXi> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:X)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeXi($scope$text);
                }
                return $$res;
            });
    }
    public matchlargePi($$dpth: number, $$cr?: ErrorTracker): Nullable<largePi> {
        return this.run<largePi>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largePi> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:P[hs]?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largePi($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeRho($$dpth: number, $$cr?: ErrorTracker): Nullable<largeRho> {
        return this.run<largeRho>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeRho> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:<?R)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeRho($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeSigma($$dpth: number, $$cr?: ErrorTracker): Nullable<largeSigma> {
        return this.run<largeSigma>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeSigma> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:S)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeSigma($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeTau($$dpth: number, $$cr?: ErrorTracker): Nullable<largeTau> {
        return this.run<largeTau>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeTau> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:Th?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeTau($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallAlpha($$dpth: number, $$cr?: ErrorTracker): Nullable<smallAlpha> {
        return this.run<smallAlpha>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallAlpha> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?a\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallAlpha($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallEpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<smallEpsilon> {
        return this.run<smallEpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallEpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`]?e)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallEpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallEta($$dpth: number, $$cr?: ErrorTracker): Nullable<smallEta> {
        return this.run<smallEta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallEta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?\^e\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallEta($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallIota($$dpth: number, $$cr?: ErrorTracker): Nullable<smallIota> {
        return this.run<smallIota>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallIota> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>"]?[\'\`~]?i)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallIota($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallOmicron($$dpth: number, $$cr?: ErrorTracker): Nullable<smallOmicron> {
        return this.run<smallOmicron>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallOmicron> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`]?o)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallOmicron($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallUpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<smallUpsilon> {
        return this.run<smallUpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallUpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>"]?[\'\`~]?[uy])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallUpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallOmega($$dpth: number, $$cr?: ErrorTracker): Nullable<smallOmega> {
        return this.run<smallOmega>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallOmega> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?[\'\`~]?\^o\|?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallOmega($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallBeta($$dpth: number, $$cr?: ErrorTracker): Nullable<smallBeta> {
        return this.run<smallBeta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallBeta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:b)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallBeta($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallGamma($$dpth: number, $$cr?: ErrorTracker): Nullable<smallGamma> {
        return this.run<smallGamma>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallGamma> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:g)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallGamma($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallDelta($$dpth: number, $$cr?: ErrorTracker): Nullable<smallDelta> {
        return this.run<smallDelta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallDelta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:d)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallDelta($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallZeta($$dpth: number, $$cr?: ErrorTracker): Nullable<smallZeta> {
        return this.run<smallZeta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallZeta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:z)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallZeta($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallKappa($$dpth: number, $$cr?: ErrorTracker): Nullable<smallKappa> {
        return this.run<smallKappa>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallKappa> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:kh?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallKappa($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallLambda($$dpth: number, $$cr?: ErrorTracker): Nullable<smallLambda> {
        return this.run<smallLambda>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallLambda> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:l)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallLambda($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallMu($$dpth: number, $$cr?: ErrorTracker): Nullable<smallMu> {
        return this.run<smallMu>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallMu> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:m)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallMu($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallNu($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNu> {
        return this.choice<smallNu>([
            () => this.matchsmallNu_1($$dpth + 1, $$cr),
            () => this.matchsmallNu_2($$dpth + 1, $$cr),
            () => this.matchsmallNu_3($$dpth + 1, $$cr),
            () => this.matchsmallNu_4($$dpth + 1, $$cr),
        ]);
    }
    public matchsmallNu_1($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNu_1> {
        return this.matchsmallNasableGammaGamma($$dpth + 1, $$cr);
    }
    public matchsmallNu_2($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNu_2> {
        return this.matchsmallNasableGammaKappa($$dpth + 1, $$cr);
    }
    public matchsmallNu_3($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNu_3> {
        return this.matchsmallNasableGammaXi($$dpth + 1, $$cr);
    }
    public matchsmallNu_4($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNu_4> {
        return this.matchsmallSingleNu($$dpth + 1, $$cr);
    }
    public matchsmallNasableGammaGamma($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNasableGammaGamma> {
        return this.run<smallNasableGammaGamma>($$dpth,
            () => {
                let $scope$suffix: Nullable<smallGamma>;
                let $$res: Nullable<smallNasableGammaGamma> = null;
                if (true
                    && this.regexAccept(String.raw`(?:n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchsmallGamma($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallNasableGammaGamma($scope$suffix);
                }
                return $$res;
            });
    }
    public matchsmallNasableGammaKappa($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNasableGammaKappa> {
        return this.run<smallNasableGammaKappa>($$dpth,
            () => {
                let $scope$suffix: Nullable<smallKappa>;
                let $$res: Nullable<smallNasableGammaKappa> = null;
                if (true
                    && this.regexAccept(String.raw`(?:n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchsmallKappa($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallNasableGammaKappa($scope$suffix);
                }
                return $$res;
            });
    }
    public matchsmallNasableGammaXi($$dpth: number, $$cr?: ErrorTracker): Nullable<smallNasableGammaXi> {
        return this.run<smallNasableGammaXi>($$dpth,
            () => {
                let $scope$suffix: Nullable<smallXi>;
                let $$res: Nullable<smallNasableGammaXi> = null;
                if (true
                    && this.regexAccept(String.raw`(?:n)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$suffix = this.matchsmallXi($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallNasableGammaXi($scope$suffix);
                }
                return $$res;
            });
    }
    public matchsmallSingleNu($$dpth: number, $$cr?: ErrorTracker): Nullable<smallSingleNu> {
        return this.run<smallSingleNu>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallSingleNu> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:n)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallSingleNu($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallXi($$dpth: number, $$cr?: ErrorTracker): Nullable<smallXi> {
        return this.run<smallXi>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallXi> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:x)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallXi($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallPi($$dpth: number, $$cr?: ErrorTracker): Nullable<smallPi> {
        return this.run<smallPi>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallPi> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:p[hs]?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallPi($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallRho($$dpth: number, $$cr?: ErrorTracker): Nullable<smallRho> {
        return this.run<smallRho>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallRho> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[<>]?r)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallRho($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallSigma($$dpth: number, $$cr?: ErrorTracker): Nullable<smallSigma> {
        return this.choice<smallSigma>([
            () => this.matchsmallSigma_1($$dpth + 1, $$cr),
            () => this.matchsmallSigma_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsmallSigma_1($$dpth: number, $$cr?: ErrorTracker): Nullable<smallSigma_1> {
        return this.matchsmallLeadingSigma($$dpth + 1, $$cr);
    }
    public matchsmallSigma_2($$dpth: number, $$cr?: ErrorTracker): Nullable<smallSigma_2> {
        return this.matchsmallSingleSigma($$dpth + 1, $$cr);
    }
    public matchsmallLeadingSigma($$dpth: number, $$cr?: ErrorTracker): Nullable<smallLeadingSigma> {
        return this.run<smallLeadingSigma>($$dpth,
            () => {
                let $scope$child: Nullable<alphabet>;
                let $$res: Nullable<smallLeadingSigma> = null;
                if (true
                    && this.regexAccept(String.raw`(?:s)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$child = this.matchalphabet($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallLeadingSigma($scope$child);
                }
                return $$res;
            });
    }
    public matchsmallSingleSigma($$dpth: number, $$cr?: ErrorTracker): Nullable<smallSingleSigma> {
        return this.run<smallSingleSigma>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallSingleSigma> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[cs])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallSingleSigma($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallTau($$dpth: number, $$cr?: ErrorTracker): Nullable<smallTau> {
        return this.run<smallTau>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallTau> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:th?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallTau($scope$text);
                }
                return $$res;
            });
    }
    public matchpunctuation($$dpth: number, $$cr?: ErrorTracker): Nullable<punctuation> {
        return this.choice<punctuation>([
            () => this.matchpunctuation_1($$dpth + 1, $$cr),
            () => this.matchpunctuation_2($$dpth + 1, $$cr),
        ]);
    }
    public matchpunctuation_1($$dpth: number, $$cr?: ErrorTracker): Nullable<punctuation_1> {
        return this.matchsemicoron($$dpth + 1, $$cr);
    }
    public matchpunctuation_2($$dpth: number, $$cr?: ErrorTracker): Nullable<punctuation_2> {
        return this.matchquestion($$dpth + 1, $$cr);
    }
    public matchsemicoron($$dpth: number, $$cr?: ErrorTracker): Nullable<semicoron> {
        return this.run<semicoron>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<semicoron> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:;)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new semicoron($scope$text);
                }
                return $$res;
            });
    }
    public matchquestion($$dpth: number, $$cr?: ErrorTracker): Nullable<question> {
        return this.run<question>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<question> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:\?)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new question($scope$text);
                }
                return $$res;
            });
    }
    public matchanyChar($$dpth: number, $$cr?: ErrorTracker): Nullable<anyChar> {
        return this.run<anyChar>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<anyChar> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:.)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new anyChar($scope$text);
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchletters(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchletters(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchletters(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "ys" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<letters>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}