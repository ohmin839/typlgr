/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* words := children=wordOrNothing*
*     .value = Array<string> {
*         return this.children
*             .map(c => c.value)
*             .filter(c => c != '')
*             ;
*     }
* wordOrNothing :=
*       word
*     | anyChar
* word := left=alphabetChank right='\''?
*     .value = string {
*         return this.left.value + (this.right ?? '');
*     }
* alphabetChank := children=alphabet+
*     .value = string {
*         return this.children.map(c => c.value).join('')
*     }
* alphabet :=
*       largeAlpha
*     | largeEpsilon
*     | largeEta
*     | largeIota
*     | largeOmicron
*     | largeUpsilon
*     | largeOmega
*     | largeRho
*     | largeConsonant
*     | smallAlpha
*     | smallEpsilon
*     | smallEta
*     | smallIota
*     | smallOmicron
*     | smallUpsilon
*     | smallOmega
*     | smallRho
*     | smallConsonant
* largeAlpha := text='[ΑἈἌᾌἊᾊἎᾎᾈἉἍᾍἋᾋᾋἏᾉΆᾺᾼ]'
*     .value = string {
*         return text;
*     }
* largeEpsilon := text='[ΕἘἜἚἙἝἛΈῈ]'
*     .value = string {
*         return text;
*     }
* largeEta := text='[ΗἨἬᾜἪᾚἮᾞᾘἩἭᾝἫᾛᾛἯᾙΉῊῌ]'
*     .value = string {
*         return text;
*     }
* largeIota := text='[ΙἸἼἺἾἹἽἻἿΊῚΪ]'
*     .value = string {
*         return text;
*     }
* largeOmicron := text='[ΟὈὌὊὉὍὋΌῸ]'
*     .value = string {
*         return text;
*     }
* largeUpsilon := text='[ΥὙὝὛὟΎῪΫ]'
*     .value = string {
*         return text;
*     }
* largeOmega := text='[ΩὨὬᾬὪᾪὮᾮᾨὩὭᾭὫᾫᾫὯᾩΏῺῼ]'
*     .value = string {
*         return text;
*     }
* largeRho := text='[ΡῬ]'
*     .value = string {
*         return text;
*     }
* largeConsonant := text='[ΒΓΔΖΘΚΛΜΝΞΠΣΤΦΧΨ]'
*     .value = string {
*         return text;
*     }
* smallAlpha := text='[αἀἄᾄἂᾂἆᾆᾀἁἅᾅἃᾃᾃἇᾁάᾴὰᾲᾶᾷᾳ]'
*     .value = string {
*         return text;
*     }
* smallEpsilon := text='[εἐἔἒἑἕἓέὲ]'
*     .value = string {
*         return text;
*     }
* smallEta := text='[ηἠἤᾔἢᾒἦᾖᾐἡἥᾕἣᾓᾓἧᾑήῄὴῂῆῇῃ]'
*     .value = string {
*         return text;
*     }
* smallIota := text='[ιἰἴἲἶἱἵἳἷίὶῖϊΐῒῗ]'
*     .value = string {
*         return text;
*     }
* smallOmicron := text='[οὀὄὂὁὅὃόὸ]'
*     .value = string {
*         return text;
*     }
* smallUpsilon := text='[υὐὔὒὖὑὕὓὗύὺῦϋΰῢῧ]'
*     .value = string {
*         return text;
*     }
* smallOmega := text='[ωὠὤᾤὢᾢὦᾦᾠὡὥᾥὣᾣᾣὧᾡώῴὼῲῶῷῳ]'
*     .value = string {
*         return text;
*     }
* smallRho := text='[ρῤῥ]'
*     .value = string {
*         return text;
*     }
* smallConsonant := text='[βγδζθκλμνξπσςτφχψ]'
*     .value = string {
*         return text;
*     }
* anyChar := text='.'
*     .value = string {
*         return '';
*     }
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    words = "words",
    wordOrNothing_1 = "wordOrNothing_1",
    wordOrNothing_2 = "wordOrNothing_2",
    word = "word",
    alphabetChank = "alphabetChank",
    alphabet_1 = "alphabet_1",
    alphabet_2 = "alphabet_2",
    alphabet_3 = "alphabet_3",
    alphabet_4 = "alphabet_4",
    alphabet_5 = "alphabet_5",
    alphabet_6 = "alphabet_6",
    alphabet_7 = "alphabet_7",
    alphabet_8 = "alphabet_8",
    alphabet_9 = "alphabet_9",
    alphabet_10 = "alphabet_10",
    alphabet_11 = "alphabet_11",
    alphabet_12 = "alphabet_12",
    alphabet_13 = "alphabet_13",
    alphabet_14 = "alphabet_14",
    alphabet_15 = "alphabet_15",
    alphabet_16 = "alphabet_16",
    alphabet_17 = "alphabet_17",
    alphabet_18 = "alphabet_18",
    largeAlpha = "largeAlpha",
    largeEpsilon = "largeEpsilon",
    largeEta = "largeEta",
    largeIota = "largeIota",
    largeOmicron = "largeOmicron",
    largeUpsilon = "largeUpsilon",
    largeOmega = "largeOmega",
    largeRho = "largeRho",
    largeConsonant = "largeConsonant",
    smallAlpha = "smallAlpha",
    smallEpsilon = "smallEpsilon",
    smallEta = "smallEta",
    smallIota = "smallIota",
    smallOmicron = "smallOmicron",
    smallUpsilon = "smallUpsilon",
    smallOmega = "smallOmega",
    smallRho = "smallRho",
    smallConsonant = "smallConsonant",
    anyChar = "anyChar",
}
export class words {
    public kind: ASTKinds.words = ASTKinds.words;
    public children: wordOrNothing[];
    public value: Array<string>;
    constructor(children: wordOrNothing[]){
        this.children = children;
        this.value = ((): Array<string> => {
        return this.children
            .map(c => c.value)
            .filter(c => c != '')
            ;
        })();
    }
}
export type wordOrNothing = wordOrNothing_1 | wordOrNothing_2;
export type wordOrNothing_1 = word;
export type wordOrNothing_2 = anyChar;
export class word {
    public kind: ASTKinds.word = ASTKinds.word;
    public left: alphabetChank;
    public right: Nullable<string>;
    public value: string;
    constructor(left: alphabetChank, right: Nullable<string>){
        this.left = left;
        this.right = right;
        this.value = ((): string => {
        return this.left.value + (this.right ?? '');
        })();
    }
}
export class alphabetChank {
    public kind: ASTKinds.alphabetChank = ASTKinds.alphabetChank;
    public children: [alphabet, ...alphabet[]];
    public value: string;
    constructor(children: [alphabet, ...alphabet[]]){
        this.children = children;
        this.value = ((): string => {
        return this.children.map(c => c.value).join('')
        })();
    }
}
export type alphabet = alphabet_1 | alphabet_2 | alphabet_3 | alphabet_4 | alphabet_5 | alphabet_6 | alphabet_7 | alphabet_8 | alphabet_9 | alphabet_10 | alphabet_11 | alphabet_12 | alphabet_13 | alphabet_14 | alphabet_15 | alphabet_16 | alphabet_17 | alphabet_18;
export type alphabet_1 = largeAlpha;
export type alphabet_2 = largeEpsilon;
export type alphabet_3 = largeEta;
export type alphabet_4 = largeIota;
export type alphabet_5 = largeOmicron;
export type alphabet_6 = largeUpsilon;
export type alphabet_7 = largeOmega;
export type alphabet_8 = largeRho;
export type alphabet_9 = largeConsonant;
export type alphabet_10 = smallAlpha;
export type alphabet_11 = smallEpsilon;
export type alphabet_12 = smallEta;
export type alphabet_13 = smallIota;
export type alphabet_14 = smallOmicron;
export type alphabet_15 = smallUpsilon;
export type alphabet_16 = smallOmega;
export type alphabet_17 = smallRho;
export type alphabet_18 = smallConsonant;
export class largeAlpha {
    public kind: ASTKinds.largeAlpha = ASTKinds.largeAlpha;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeEpsilon {
    public kind: ASTKinds.largeEpsilon = ASTKinds.largeEpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeEta {
    public kind: ASTKinds.largeEta = ASTKinds.largeEta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeIota {
    public kind: ASTKinds.largeIota = ASTKinds.largeIota;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeOmicron {
    public kind: ASTKinds.largeOmicron = ASTKinds.largeOmicron;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeUpsilon {
    public kind: ASTKinds.largeUpsilon = ASTKinds.largeUpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeOmega {
    public kind: ASTKinds.largeOmega = ASTKinds.largeOmega;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeRho {
    public kind: ASTKinds.largeRho = ASTKinds.largeRho;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class largeConsonant {
    public kind: ASTKinds.largeConsonant = ASTKinds.largeConsonant;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallAlpha {
    public kind: ASTKinds.smallAlpha = ASTKinds.smallAlpha;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallEpsilon {
    public kind: ASTKinds.smallEpsilon = ASTKinds.smallEpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallEta {
    public kind: ASTKinds.smallEta = ASTKinds.smallEta;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallIota {
    public kind: ASTKinds.smallIota = ASTKinds.smallIota;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallOmicron {
    public kind: ASTKinds.smallOmicron = ASTKinds.smallOmicron;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallUpsilon {
    public kind: ASTKinds.smallUpsilon = ASTKinds.smallUpsilon;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallOmega {
    public kind: ASTKinds.smallOmega = ASTKinds.smallOmega;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallRho {
    public kind: ASTKinds.smallRho = ASTKinds.smallRho;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class smallConsonant {
    public kind: ASTKinds.smallConsonant = ASTKinds.smallConsonant;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return text;
        })();
    }
}
export class anyChar {
    public kind: ASTKinds.anyChar = ASTKinds.anyChar;
    public text: string;
    public value: string;
    constructor(text: string){
        this.text = text;
        this.value = ((): string => {
        return '';
        })();
    }
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchwords($$dpth: number, $$cr?: ErrorTracker): Nullable<words> {
        return this.run<words>($$dpth,
            () => {
                let $scope$children: Nullable<wordOrNothing[]>;
                let $$res: Nullable<words> = null;
                if (true
                    && ($scope$children = this.loop<wordOrNothing>(() => this.matchwordOrNothing($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = new words($scope$children);
                }
                return $$res;
            });
    }
    public matchwordOrNothing($$dpth: number, $$cr?: ErrorTracker): Nullable<wordOrNothing> {
        return this.choice<wordOrNothing>([
            () => this.matchwordOrNothing_1($$dpth + 1, $$cr),
            () => this.matchwordOrNothing_2($$dpth + 1, $$cr),
        ]);
    }
    public matchwordOrNothing_1($$dpth: number, $$cr?: ErrorTracker): Nullable<wordOrNothing_1> {
        return this.matchword($$dpth + 1, $$cr);
    }
    public matchwordOrNothing_2($$dpth: number, $$cr?: ErrorTracker): Nullable<wordOrNothing_2> {
        return this.matchanyChar($$dpth + 1, $$cr);
    }
    public matchword($$dpth: number, $$cr?: ErrorTracker): Nullable<word> {
        return this.run<word>($$dpth,
            () => {
                let $scope$left: Nullable<alphabetChank>;
                let $scope$right: Nullable<Nullable<string>>;
                let $$res: Nullable<word> = null;
                if (true
                    && ($scope$left = this.matchalphabetChank($$dpth + 1, $$cr)) !== null
                    && (($scope$right = this.regexAccept(String.raw`(?:\')`, "", $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = new word($scope$left, $scope$right);
                }
                return $$res;
            });
    }
    public matchalphabetChank($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabetChank> {
        return this.run<alphabetChank>($$dpth,
            () => {
                let $scope$children: Nullable<[alphabet, ...alphabet[]]>;
                let $$res: Nullable<alphabetChank> = null;
                if (true
                    && ($scope$children = this.loopPlus<alphabet>(() => this.matchalphabet($$dpth + 1, $$cr))) !== null
                ) {
                    $$res = new alphabetChank($scope$children);
                }
                return $$res;
            });
    }
    public matchalphabet($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet> {
        return this.choice<alphabet>([
            () => this.matchalphabet_1($$dpth + 1, $$cr),
            () => this.matchalphabet_2($$dpth + 1, $$cr),
            () => this.matchalphabet_3($$dpth + 1, $$cr),
            () => this.matchalphabet_4($$dpth + 1, $$cr),
            () => this.matchalphabet_5($$dpth + 1, $$cr),
            () => this.matchalphabet_6($$dpth + 1, $$cr),
            () => this.matchalphabet_7($$dpth + 1, $$cr),
            () => this.matchalphabet_8($$dpth + 1, $$cr),
            () => this.matchalphabet_9($$dpth + 1, $$cr),
            () => this.matchalphabet_10($$dpth + 1, $$cr),
            () => this.matchalphabet_11($$dpth + 1, $$cr),
            () => this.matchalphabet_12($$dpth + 1, $$cr),
            () => this.matchalphabet_13($$dpth + 1, $$cr),
            () => this.matchalphabet_14($$dpth + 1, $$cr),
            () => this.matchalphabet_15($$dpth + 1, $$cr),
            () => this.matchalphabet_16($$dpth + 1, $$cr),
            () => this.matchalphabet_17($$dpth + 1, $$cr),
            () => this.matchalphabet_18($$dpth + 1, $$cr),
        ]);
    }
    public matchalphabet_1($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_1> {
        return this.matchlargeAlpha($$dpth + 1, $$cr);
    }
    public matchalphabet_2($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_2> {
        return this.matchlargeEpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_3($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_3> {
        return this.matchlargeEta($$dpth + 1, $$cr);
    }
    public matchalphabet_4($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_4> {
        return this.matchlargeIota($$dpth + 1, $$cr);
    }
    public matchalphabet_5($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_5> {
        return this.matchlargeOmicron($$dpth + 1, $$cr);
    }
    public matchalphabet_6($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_6> {
        return this.matchlargeUpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_7($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_7> {
        return this.matchlargeOmega($$dpth + 1, $$cr);
    }
    public matchalphabet_8($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_8> {
        return this.matchlargeRho($$dpth + 1, $$cr);
    }
    public matchalphabet_9($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_9> {
        return this.matchlargeConsonant($$dpth + 1, $$cr);
    }
    public matchalphabet_10($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_10> {
        return this.matchsmallAlpha($$dpth + 1, $$cr);
    }
    public matchalphabet_11($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_11> {
        return this.matchsmallEpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_12($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_12> {
        return this.matchsmallEta($$dpth + 1, $$cr);
    }
    public matchalphabet_13($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_13> {
        return this.matchsmallIota($$dpth + 1, $$cr);
    }
    public matchalphabet_14($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_14> {
        return this.matchsmallOmicron($$dpth + 1, $$cr);
    }
    public matchalphabet_15($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_15> {
        return this.matchsmallUpsilon($$dpth + 1, $$cr);
    }
    public matchalphabet_16($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_16> {
        return this.matchsmallOmega($$dpth + 1, $$cr);
    }
    public matchalphabet_17($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_17> {
        return this.matchsmallRho($$dpth + 1, $$cr);
    }
    public matchalphabet_18($$dpth: number, $$cr?: ErrorTracker): Nullable<alphabet_18> {
        return this.matchsmallConsonant($$dpth + 1, $$cr);
    }
    public matchlargeAlpha($$dpth: number, $$cr?: ErrorTracker): Nullable<largeAlpha> {
        return this.run<largeAlpha>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeAlpha> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΑἈἌᾌἊᾊἎᾎᾈἉἍᾍἋᾋᾋἏᾉΆᾺᾼ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeAlpha($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeEpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<largeEpsilon> {
        return this.run<largeEpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeEpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΕἘἜἚἙἝἛΈῈ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeEpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeEta($$dpth: number, $$cr?: ErrorTracker): Nullable<largeEta> {
        return this.run<largeEta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeEta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΗἨἬᾜἪᾚἮᾞᾘἩἭᾝἫᾛᾛἯᾙΉῊῌ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeEta($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeIota($$dpth: number, $$cr?: ErrorTracker): Nullable<largeIota> {
        return this.run<largeIota>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeIota> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΙἸἼἺἾἹἽἻἿΊῚΪ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeIota($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeOmicron($$dpth: number, $$cr?: ErrorTracker): Nullable<largeOmicron> {
        return this.run<largeOmicron>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeOmicron> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΟὈὌὊὉὍὋΌῸ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeOmicron($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeUpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<largeUpsilon> {
        return this.run<largeUpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeUpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΥὙὝὛὟΎῪΫ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeUpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeOmega($$dpth: number, $$cr?: ErrorTracker): Nullable<largeOmega> {
        return this.run<largeOmega>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeOmega> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΩὨὬᾬὪᾪὮᾮᾨὩὭᾭὫᾫᾫὯᾩΏῺῼ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeOmega($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeRho($$dpth: number, $$cr?: ErrorTracker): Nullable<largeRho> {
        return this.run<largeRho>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeRho> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΡῬ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeRho($scope$text);
                }
                return $$res;
            });
    }
    public matchlargeConsonant($$dpth: number, $$cr?: ErrorTracker): Nullable<largeConsonant> {
        return this.run<largeConsonant>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<largeConsonant> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ΒΓΔΖΘΚΛΜΝΞΠΣΤΦΧΨ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new largeConsonant($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallAlpha($$dpth: number, $$cr?: ErrorTracker): Nullable<smallAlpha> {
        return this.run<smallAlpha>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallAlpha> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[αἀἄᾄἂᾂἆᾆᾀἁἅᾅἃᾃᾃἇᾁάᾴὰᾲᾶᾷᾳ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallAlpha($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallEpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<smallEpsilon> {
        return this.run<smallEpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallEpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[εἐἔἒἑἕἓέὲ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallEpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallEta($$dpth: number, $$cr?: ErrorTracker): Nullable<smallEta> {
        return this.run<smallEta>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallEta> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ηἠἤᾔἢᾒἦᾖᾐἡἥᾕἣᾓᾓἧᾑήῄὴῂῆῇῃ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallEta($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallIota($$dpth: number, $$cr?: ErrorTracker): Nullable<smallIota> {
        return this.run<smallIota>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallIota> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ιἰἴἲἶἱἵἳἷίὶῖϊΐῒῗ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallIota($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallOmicron($$dpth: number, $$cr?: ErrorTracker): Nullable<smallOmicron> {
        return this.run<smallOmicron>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallOmicron> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[οὀὄὂὁὅὃόὸ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallOmicron($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallUpsilon($$dpth: number, $$cr?: ErrorTracker): Nullable<smallUpsilon> {
        return this.run<smallUpsilon>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallUpsilon> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[υὐὔὒὖὑὕὓὗύὺῦϋΰῢῧ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallUpsilon($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallOmega($$dpth: number, $$cr?: ErrorTracker): Nullable<smallOmega> {
        return this.run<smallOmega>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallOmega> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ωὠὤᾤὢᾢὦᾦᾠὡὥᾥὣᾣᾣὧᾡώῴὼῲῶῷῳ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallOmega($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallRho($$dpth: number, $$cr?: ErrorTracker): Nullable<smallRho> {
        return this.run<smallRho>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallRho> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[ρῤῥ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallRho($scope$text);
                }
                return $$res;
            });
    }
    public matchsmallConsonant($$dpth: number, $$cr?: ErrorTracker): Nullable<smallConsonant> {
        return this.run<smallConsonant>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<smallConsonant> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:[βγδζθκλμνξπσςτφχψ])`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new smallConsonant($scope$text);
                }
                return $$res;
            });
    }
    public matchanyChar($$dpth: number, $$cr?: ErrorTracker): Nullable<anyChar> {
        return this.run<anyChar>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<anyChar> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?:.)`, "", $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new anyChar($scope$text);
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchwords(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchwords(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchwords(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<words>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}